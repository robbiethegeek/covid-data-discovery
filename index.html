<!doctype html>
<html class="no-js" lang="en-US">

<head>
  <meta charset="utf-8">
  <title>COVID Data Website</title>
  <meta name="description" content="COVID-19 Data Discovery">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="text/javascript">

const init = () => {
  const defaultState = { 
    data: null,
    meta: null,
    Plotly: null,
    formOptions: { region: ['Earth'], subregions: null },  
    filters: {region: ['Earth'], metric: ['cases'], showSubregions: false, perCapita: false,
      prettyText: {
        "cases": "Cases",
        "deaths": "Deaths",
        "caseChange": "Daily Case Change (#)",
        "caseChangePercent": "Daily Case Change (%)",
        "deathsChange": "Daily Deaths Change (#)",
        "deathsChangePercent": "Daily Deaths Change (%)",
        "survivalRate": "Survival Rate (%)"
      }
    },
    debug: true,
    plot: { 
      target: (id = 'plot') => { return document.getElementById(id) },
      config: undefined 
    },
    table: {
      timeFormat: { month: 'short', day: 'numeric', timeZone: 'UTC' } // use with toLocaleDateString
    },
    listeners: [],
  }  
return function App (state = defaultState) {
  this.log = output => console.debug(output)
  this.state = state
  this.updateTimestamp = (timeString = `${new Date(this.state.meta.lastUpdated).toLocaleString(undefined, {month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric', timeZoneName: 'short'})}`, className = '.last-updated') => { document.querySelector(className).innerText = `Last updated: ${timeString}` }
  this.updateState = (newState) => {
    if(this.state.debug) {
      this.log('=== Current State ===')
      this.log(this.state)
      this.log('=== State update ===')
      this.log(newState)
    }
    this.state = { ...this.state, ...newState }
    if(newState.filters) this.updatePlot('plot') // This is really the only state listener needed at the moment, so listener capability is stubbed out.
    if(this.state.debug) {
      this.log('=== New State ===')
      this.log(this.state)
      this.log(' ')
    }
    // this.state.listeners.forEach(thisListener => thisListener()); // Building the plot is a heavy operation with all the data to date, and a plot build will kick off unnecessarily like this. Stubbing this for now, but might incorporate this later in a smarter way. 
    return this.state
  }
  this.updatePlotTitle = newTitle => {
    document.querySelector('.floating-plot-title').innerText = newTitle
  }
  this.updateLoadingUI = async obj => { // {num, total, name}
    const loadingUI = document.querySelector(`.${obj.name}`) // Not checking to see if it exists first because it is part of the initial load in the HTML. This could change if more things get loaded in.
    if(obj.num === obj.total) {
      loadingUI.innerText = `Fetching ${obj.name}: Complete.` 
    } else {
      const num = Math.floor(Number(obj.num) / 1000)
      const total = Math.floor(Number(obj.total) / 1000)
      const percent = Math.floor((num/total) * 100) 
      loadingUI.innerText = `Fetching ${obj.name}: ${percent}%` 
    }
  }
  this.updateFetchProgress = async (fetchObj) => {
    try {
      const decoder = new TextDecoder('utf-8')
      const response = await fetch(fetchObj.url, fetchObj.options);
      if(!response.ok) throw new Error(`Issue fetching ${fetchObj.prettyName}: ${response.statusText}`)
      const total = Number(response.headers.get('File-Size'));
      const contentType = response.headers.get('content-type');

      const reader = response.body.getReader(); // Grabbed this from stack overflow and stumbled into the world of handling streams. Did some learnin', for sure.
      let bytesReceived = 0;
      let body = ''
      let eventCount = 0
      while (true) {
        const result = await reader.read()
        if (result.done) {
          this.updateLoadingUI({num: total, total, name: fetchObj.prettyName})          
          if (!contentType || !contentType.includes('application/json')) {
            return eval(body) // Umm...eval is pretty unsafe if you're not 100% sure of the content it's evaluating. Running eval on all network calls seems like a pretty bad idea. Refactor this to use a writeable stream to get the result of the network call into a variable that's returned, or something like that. For now...it'll be served over HTTPS from only private resources I own...so...safe enough? Oof. Bad. Don't @ me. 
          } else {
            return eval(body)
          }
          break;
        }
        bytesReceived += result.value.byteLength;
        if(eventCount % 10 === 0 && eventCount > 0) {
          this.updateLoadingUI({num: bytesReceived, total, name: fetchObj.prettyName})
          eventCount++
        } else {
          eventCount++
        }
        body += decoder.decode(result.value)
      }
    } catch(err) {
      console.error(err)
      throw err
    }
  }
  this.fetchAll = async (arrOfFetches) => { // [{ url, options, prettyName: 'Data' }, { url, options, prettyName: 'Charts' }...]
    return Promise.all(
      arrOfFetches.map( async thisFetch => { 
        try {
          let result = await this.updateFetchProgress(thisFetch)
          return result
        } catch(err) {
          throw err
        }
      })
    )
    .catch(err => { alert(`Failed to load some necessary ingredients; Try reloading the page, then checking your internet connection. If the problem persists, report the issue at https://github.com/trycrmr/covid-data-discovery/issues

For those interested, this is what happened: 

${err}`) } ) // So if something weird happens over the network that results in a 4xx or 5xx tell the user about it and let them know what to do next.
  }
  this.createFullLocationList = (locationNode = this.state.data) => {
    const getAllLocations = root => {
      if(Object.keys(root.subregions).length === 0) {
        return [ root.name ]
      }
      return [ root.name, ...Object.keys(root.subregions).map(thisSubregion => {
        return getAllLocations(root.subregions[thisSubregion]).flat()
      }).flat()]
    }
    const allLocations = getAllLocations(locationNode)
    // allLocations.forEach(thisLocation => {
    //   let locationSpan = this.state.filters.region.includes(thisLocation) ? `<span class="location-tag ${this.getCSSSafeString(thisLocation)}" >${thisLocation} <span class="remove-location">X</span></span>` : `<span class="location-tag ${this.getCSSSafeString(thisLocation)}" style="display: none;" >${thisLocation} <span class="add-location">+</span></span>`
    //   document.querySelector('.search-container').insertAdjacentHTML('beforeend', locationSpan)
    // })
    this.updateState({allLocations})
    
  }
  // this.getCSSSafeString = str => str.replace(/[!\"#$%&'\(\)\*\+,\.\/:;<=>\?\@\[\\\]\^`\{\|\}~]/g, '').split(' ').join('')
  this.locationSearch = (str, limit = 20) => { // Limit because, like, really, type another character and get more specific with your search if there are more than 20 results. Was 30, but there is a scrolling issue with that many options
    if(str.length === 1 || str.length === 2) return undefined // Cheap debounce. Like, no need to do so many operations for one or character search. C'mon. And the shortest locations are four characters long, so no locations are being left out.
    document.querySelector('.tags').remove()
    let html = '<div class="tags"><div class="selected-tags">'
    this.state.filters.region.forEach(thisRegion => {
      html += `<span class="location-tag">${thisRegion} <span class="remove-location">X</span></span>`
    })
    html += '</div>'

    let count = 0
    if(str.length > 0 && !this.state.filters.region.includes(str)) {
      const iterator = this.state.allLocations.values();
      for (const value of iterator) {
        if(this.state.filters.region.includes(value)) continue // Don't create an add-location span if this location is in the filters
        if(value.toLowerCase().includes(str.toLowerCase())) {
          html += `<span class="location-tag">${value} <span class="add-location">+</span></span>`
          count++
          if(count > limit) break
        }
      }
    }
    if(str.length > 2 && !count) html += '<span class="no-results">No location results. Try some different letters.</span>'
    html += '</div>'
    const locationTagElems = document.createRange().createContextualFragment(html)
    locationTagElems.querySelectorAll('span.location-tag').forEach(thisLocationTag => {
      thisLocationTag.addEventListener('click', event => { // Oof. Really don't love this event listener. Brittle and adds dependency on the structure of the HTML. Alas, here we are.
        let regionText = event.target.className === 'add-location' || event.target.className === 'remove-location' ? event.target.parentElement.innerText : event.target.innerText
        this.setFilters('region', regionText.substring(0,regionText.length - 2)) // Don't love this, but here we are. 
        this.locationSearch(str)
        return undefined // Maybe not necessary. I thought it might speed up the execution time to return out of the function after kicking off the other functions. Who really knows how JavaScript works, anyways???
      })
    })
    document.querySelector('.search-container').appendChild(locationTagElems)

  }
  this.updateForm = (formSelection = 'Earth') => {
    let locationNode = this.findLocation(formSelection)
    let updatedState = this.updateState( { formOptions: {region: [ locationNode.name ], subregions: Object.keys(locationNode.subregions) } })

    ;((obj) => {
      let regionForm = document.getElementsByName('filter-regions')[0]
      regionForm.options.length = 0
      obj.region.forEach(thisRegion => { regionForm.options.add(new Option(thisRegion, thisRegion, false, false)) })
      while(locationNode.superRegionName) { // Will run until Earth, which has a null super region
        locationNode = this.findLocation(locationNode.superRegionName) // Could be a a perf issue eventually. No noticeable lag at the moment. 
        regionForm.options.add(new Option(locationNode.name, locationNode.name, false, false))
      }
      let subregionForm = document.getElementsByName('filter-subregions')[0]
      subregionForm.options.length = 0
      if(obj.subregions.length === 0) {
        subregionForm.options.add(new Option('No subregions available', 'Earth', false, false))
      } else {
        subregionForm.options.add(new Option('(Select a subregion)', 'Earth', false, false))
        obj.subregions.sort().forEach(thisSubregion => { subregionForm.options.add(new Option(thisSubregion, thisSubregion, false, false)) })
      }
    })(updatedState.formOptions)
    return undefined
  }
  this.findLocation = (str, obj = this.state.data) => {
    let match = null
    if(str === obj.name) {
      match = obj
      return match
    }
    if(Object.entries(obj.subregions).length > 0) {
      for (let [key, thisSubregion] of Object.entries(obj.subregions)) {
        match = this.findLocation(str, thisSubregion)
        if(!match) {
          // do nothing
        } else {
          return match
        }
      }
    }
    return match
  }
  this.setFilters = (type, filters) => {
    switch(type) {
      case 'region':
        if(this.state.filters.region.includes(filters) && this.state.filters.region.length > 1) // Toggles region filter instead of only adding
          return this.updateState( { filters: { ...this.state.filters, region: this.state.filters.region.filter(thisElem => filters !== thisElem) } } )
        
        if(this.state.filters.region.includes(filters)) return undefined // Don't do anything if there is only one filter
        return this.updateState( { filters: { ...this.state.filters, region: [ ...this.state.filters.region, filters ] } } )
      case 'metric':
        return this.updateState( { filters: { ...this.state.filters, metric: [ ...filters ] } } )
      case 'perCapita':
        console.info(filters)
        return this.updateState( { filters: { ...this.state.filters, perCapita: filters } } ) // filters would be a boolean here
      case 'showSubregions':
        return this.updateState( { filters: { ...this.state.filters, showSubregions: filters } } )
      default:
        return this.state
    }
  }
  this.updatePlot = async (id, type) => { 
    let thisPlotConfig = this.getPlotConfig(type, this.state.filters)
    let newState = this.updateState( { plot: { ...this.state.plot, ... { config: { data: thisPlotConfig[0], layout: thisPlotConfig[1], config: thisPlotConfig[2] } } } } ) 
    this.state.plot.target(id)
    document.querySelector('div.table').remove()
    setTimeout( async () => {
      await Plotly.newPlot(this.state.plot.target(id), newState.plot.config.data, newState.plot.config.layout, newState.plot.config.config).catch(err => console.error(err)) // Handle this error some other way later. Also, await so the form is hidden & shown appropriately.
      document.getElementById(id).append(this.generateTable(newState.plot.config.data, { title: newState.plot.config.layout.title.text }))
      this.updatePlotTitle(newState.plot.config.layout.title.text)
    }, 10) // Give the browser a breath to update the UI
  }
  this.conjunctionize = arr => { // LOL a refactored code golf answer https://codegolf.stackexchange.com/a/37726/94505 
    let length = arr.length;
    if(length <= 1) return arr.join() // just return a stringifyed array if less than two
    if(length > 2) arr[length - 1] = 'and ' + arr[length - 1] // if longer than two characters, append "and" to the last element
    return arr.join(length > 2 ? ', ' : ' and ') // if longer than two characters join the array together with either commas or "and"
  }
  this.getPlotConfig = (type = 'time series', filters = this.state.filters, plotLayout = undefined) => {
    let plotConfig = { // Odd naming, but the third argument to Plotly.newPlot() is technically called "config" https://plotly.com/javascript/plotlyjs-function-reference/#plotlynewplot
      responsive: true,
      doubleClickDelay: 500 // default is 300, but 500 is the Windows default. A user was having trouble https://github.com/trycrmr/covid-data-discovery/issues/90 
    }
    let calculatedHeight
    let calculatedMarginWidth
    let currentFontSize = parseFloat(getComputedStyle(this.state.plot.target()).fontSize)
    plotLayout = { title: {
      text: `${
      this.conjunctionize(
        this.state.filters.metric
        .map(thisMetric => this.state.filters.prettyText[thisMetric])
        .sort((a, b) => a.localeCompare(b))
      )
      }${this.state.filters.region.length <= 1 ? '' : this.state.filters.perCapita ? ', per 100,000 folks,' : ', not population-adjusted,'} for ${this.conjunctionize(this.state.filters.region.map(e=>e))}`, // mapped so a copy is passed to the function instead of passing a reference to the state. Was updating state with dirty region values otherwise (ex. "and China")
      font: {
        color: '#FFF', // Hide the plotly title
        size: 1
      }
    }
      
    },
    plotLayout = { 
      ...plotLayout,
      margin: { t: 70 }, // Removes the space the 
      font: {
        family: getComputedStyle(document.getElementById('plot')).fontFamily,
        size: getComputedStyle(document.getElementById('plot')).fontSize,
        color: getComputedStyle(document.getElementById('plot')).color
      },
      autosize: false,
      width: parseFloat(getComputedStyle(this.state.plot.target()).width),
      height: window.innerHeight - (document.querySelector('header').offsetHeight) - 72 > 600 ? window.innerHeight - (document.querySelector('header').offsetHeight) - 72 : 600,
      // height needs to be set dynamically based on the screen size and height of other items on the screen. Ideally, when the filters are hidden, the bottom of the chart should be just above the fold. 
      yaxis: { 
        tickfont: { size: currentFontSize }, 
      }
    }
    if(this.state.filters.metric.length > 1) plotLayout = { ...plotLayout, barmode: 'group'  }
    let plotData = undefined
    switch(type) { // Written as a switch keeping the future feature open to allow the user to select different types of charts. Tough to ensure the UI looks decent between each of the charts with all the cuts of the metrics over time, but it's possible. 
      case 'time series':
        const timeFormat = {month: 'short', day: 'numeric', timeZone: 'UTC' } // use with toLocaleDateString to create x-axis dates
        // let locationNode = this.findLocation(this.state.filters.region[0])
        // let locationNodes = this.state.filters.showSubregions && Object.keys(locationNode.subregions).length > 0 ? [...Object.keys(locationNode.subregions).map(thisSubregion => locationNode.subregions[thisSubregion]), locationNode ] : [ locationNode ]
        let locationNodes = this.state.filters.region.map(thisRegion => this.findLocation(thisRegion))
        //^ If the user wants the subregions visualized and the location has subregions, get the subregions. Otherwise, just return the location.
        plotData = this.state.filters.metric.map(thisMetric => {
          let locationsWithoutData = []
          return locationNodes.reduce((acc, curr, currIdx, origArr) => {
            let threeRandomNumbers = new Array(3).fill(null).map(thisElem => Math.floor(Math.random() * 200).toFixed(0)) // 255, 255, 255 is white, so that's why 200 is arbitrarily picked. Darker, but different colors is probably good for viewing. 
            let thisColor = `rgb(${threeRandomNumbers[0]},${threeRandomNumbers[1]},${threeRandomNumbers[2]})`
            try {
              let obj = { x: [], y: [], text: [], type: 'scatter', mode: 'lines+markers', line: { color: thisColor }, markers: { color: thisColor }, name: `${curr.name} (${this.state.filters.prettyText[thisMetric]})`, hoverlabel: { namelength :-1 } /* Hoverlabel -1 ensures the labels that show on hover are not cut off and replaced with an ellipsis */ }
              // if(this.state.filters.region[0] === curr.name && locationNodes.length > 1) obj = { ...obj, line: { width: 1, dash: 'dot' }, marker: { size: 8 } }
              if(this.state.filters.perCapita) { 
                if(`${thisMetric}Per100000` in curr.totals.daily) {
                  obj.x = [ ...Object.keys(curr.totals.daily[`${thisMetric}Per100000`]).map(thisUnixEpochString => parseInt(thisUnixEpochString)) ]
                  obj.y = [ ...Object.values(curr.totals.daily[`${thisMetric}Per100000`]) ]
                } else {
                  alert(`${thisMetric}Per100000 does not exist for ${curr.name}.`)
                }
              } else {
                obj.x = [ ...Object.keys(curr.totals.daily[thisMetric]).map(thisUnixEpochString => parseInt(thisUnixEpochString)) ]
                obj.y = [ ...Object.values(curr.totals.daily[thisMetric]) ]
              }
              if(parseInt(obj.x[0]) > parseInt(obj.x[1])) { // band aid fix to preserve order. Date to metric key-value pairs are stored as a hashmap and that's making it real tough to ensure the order. https://github.com/trycrmr/covid-data-batch-server/issues/6
                obj.x = obj.x.reverse()
                obj.y = obj.y.reverse()
              }

              if((thisMetric === 'caseChangePercent' || thisMetric === 'deathsChangePercent')) { // When deriving these metrics the first day of a time series, I guess, technically, would be 100% change from the previous day, which is effectively zero. This skews the plots, especially when the percent change should approach zero. Handling this on the back-end when the derived calculations are generated wouldn't work because null values are type cast to zero when generating the aggregates. That necessitates this hard check and setting the first value if it's a percent aggregate and the percent aggregate is 100 (i.e. 100%)
                let i = 0
                while(i < obj.y.length) { // A little nervous about the while loop with performance, but so far no noticeable loss on local development. 
                  if( (!+(obj.y[i]) || obj.y[i] === "0.00" ) || obj.y[i] === "100.00") { // Woof. If the value when type cast to a number is falsy OR the it's equal to "0.00" (a legitimate value) set it to null. ALSO if the value is "100.00" it's the first day of counts were recorded, but that messes up the visualization, so set that one to null too. Oof. 
                    obj.y[i] = null
                    i++
                    if(i === obj.y.length) locationsWithoutData.sort().push(curr.name)
                  } else {
                    break
                  }
                }
              } 
              // obj.x = obj.x.map(thisUnixEpoch => new Date(thisUnixEpoch).toLocaleDateString(undefined, timeFormat)) 
              obj.x = obj.x.map(thisUnixEpoch => new Date(thisUnixEpoch)) 
              if(locationsWithoutData.length > 0 && locationNodes.length === 1) alert(`${curr.name} does not have any ${this.state.filters.prettyText[thisMetric]} data. This is okay! 

It means this is either the first day cases or deaths were recorded for ${curr.name} and a percentage-based derived metric is selected or there haven't been any cases or deaths of COVID-19 reported so far! 

If you do not believe that's the situation, please report an issue (use the link at the top of the page) with the filters (i.e metrics & locations) you have selected.
              `)
              //^ This is for all the lovely people in Ouray, Colorado :-) . Sorry about reporting your first case on April 6th, and your first death around April 10th :-( . Use the state of Wyoming, select all the metrics, and show subregions to test instead. 
              return [ ...acc, obj ]
            } catch(err) {
              console.error(err)
              return acc
            }
          }, [])
        }).flat()

        plotLayout = { ...plotLayout, 
          ...{
            // hovermode: 'closest', // Hover will only show the closest point to the cursor, instead of all the points on that part of the x-axis. Leaving option for reference and to toggle for UX experiments on occasion. 
            showLegend: true,
            legend: { "orientation": 'h', x: 0, y: 0 },
            xaxis: { // puts the x-axis on the top of the page so the user can see the scale when the page loads and as they adjust the filters
              ...plotLayout.xaxis,
              type: 'date',
              mirror: 'allticks',
              side: plotData.length > 1 ? 'top' : 'bottom',
              fixedrange: false, // disables zoom; It can be disorienting and makes scrolling more difficult on mobile
              showspikes: true, // on hover, a dotted line will track to either axis and display the labels,
              tickformat: '%b %d',
              dtick: 604800000.0, // unix millisecond format. Not sure what the decimal is for.
              rangeslider: {
                visible: false
              }
            },
            yaxis: { ...plotLayout.yaxis,
              fixedrange: true,
              showspikes: true,
            }
          }  
        }

        plotConfig = { ...plotConfig, 
        ...{
          // displaylogo: false // Put this here commented out to denote that I don't mind leaving the logo. If plot.ly gets some free publicity, good for them. It's my little way of giving a thumbs up to their open source work. 
          modeBarButtonsToRemove: ["hoverClosestCartesian", "hoverCompareCartesian","zoomInGeo", "zoomOutGeo", "resetGeo", "hoverClosestGeo","zoom2d", "pan2d", "select2d", "lasso2d", "zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d","zoom3d", "pan3d", "orbitRotation", "tableRotation", "handleDrag3d", "resetCameraDefault3d", "resetCameraLastSave3d", "hoverClosest3d","hoverClosestGl2d", "hoverClosestPie", "toggleHover", "resetViews", "toImage", "sendDataToCloud", "toggleSpikelines", "resetViewMapbox"]
          .filter(thisButton => !['toImage', 'resetScale2d'].includes(thisButton)),
          displayModeBar: true
        }}
        break
      default:
        plotData = [
          {
            x: ['oops', 'something', 'went', 'wrong'],
            y: [20, 14, 23, 12],
            type: 'bar'
          }
        ]
    }
    return [plotData, plotLayout, plotConfig]
  }
  this.generateTable = (data, details) => {
    let header = data.reduce((acc, curr, currIdx, origArr) => {
      let thisRow = `<th>${curr.name}</th>`
      if(currIdx === origArr.length - 1) thisRow += '</tr></thead>'
      return acc += thisRow
    }, '<thead><tr><th></th>')

    let dataPointIdx = data[0].x.length - 1
    let metricCount = data.length
    let rows = '<tbody>'
    for (; dataPointIdx >= 0; dataPointIdx--) {
      rows += `<tr><th>${data[0].x[dataPointIdx].toLocaleDateString(undefined, this.state.table.timeFormat)}</th>`
      for (let j = 0; j < metricCount; j++) {
        rows += `<td>${data[j].y[dataPointIdx]}</td>`
        if(metricCount - 1 === j) rows += `</tr>`
      }
    }

    let html = `<div class="table" id="table"><table><caption>${details.title}</caption>${header}${rows}`
    html += `</tbody></table></div>`
    return document.createRange().createContextualFragment(html)
  }
}

}
  </script>
  <!-- <link rel="manifest" href="site.webmanifest"> -->
  <!-- <link rel="apple-touch-icon" href="icon.png"> -->
  <!-- Place favicon.ico in the root directory -->
  <!-- ^ Some stuff from HTML5 boilerplate for later I don't want to forget about. -->
</head>

<style>
  hr {
    width: 40%;
    max-width: 400px;
    margin: 0.2em auto;
  }
  header {
    margin: auto;
    max-width: 1000px;
    text-align: center;
  }
  h1, h2, h3, h4, h5, h6 {
    margin: 0.5em;
  }
  details {
    list-style: none;
  }
  .hide {
    display: none !important;
  }
  .disable-scroll {
    overflow-y: hidden;
  }
  .flex-vertically { /* https://stackoverflow.com/a/37923258/5935694 */
    display: flex;
    flex-direction: column;
    justify-content: end;
    height: 100%;
    overflow-y: auto;
  }
  .sticky-nav {
    position: -webkit-sticky;
    position: sticky;
    top: 0px;
    right: 1em;
    background-color: white;
    height: 100%;
    width: 100%;
    z-index: 999;
  }
  .toggle-menu {
    position: fixed;
    bottom: 1em;
    right: 1em;
    z-index: 1000;
    background-color: whitesmoke;
    padding: 0.2em;
    margin: 0.2em;
    border-radius: 0.2em;
    font-weight: 700;
    border: 0.05em solid black;
    /* font-size: 0.8em; */
    cursor: pointer;
  }
  .sticky-things { /* In learning about z-index, here's a wrapper in case covering the form makes sense for some reason in the future. Was from some dev that isn't going to get deployed. Also, kinda don't want to refactor this out the off chance it's used again. That's more of an excuse though. ¯\_(ツ)_/¯ */
    position: -webkit-sticky;
    position: sticky;
    top: 1em;
    margin: 0.2em auto;
    height: fit-content;
    max-width: 780px;
    width: 100%;
    z-index:998;
  }
  .sticky-form {
    z-index: 999;
    max-height: 320px;
    background-color: white;
  }
  nav.main-menu {
    position: -webkit-sticky;
    position: fixed;
    top: 0;
    left: 0;
    background-color: whitesmoke;
    margin: auto;
    /* height: max-content; */
    height: 100%;
    width: 100%;
    z-index: 999;
    opacity: 98%;
    /* overflow: scroll; */
  }
  nav.main-menu ul {
    list-style-type: none;
    padding: 0px;
  }
  nav.main-menu details {
    padding: 0.5em 10%;
    font-size: 1em;
  }
  nav.main-menu details summary::-webkit-details-marker {
    display:none;
  }
  nav.main-menu summary {
    cursor: pointer;
    padding: 0.25em;
    text-align: center;
    font-size: 1.2em;
  }
  body {
    font-family: 'Times New Roman';
    position: relative;
  }
  select {
    font-family: 'Times New Roman';
    font-size: 1em;
    background-color: black;
    color: white;
    font-weight: bold;
    border-radius: 0.5em;
    text-align-last: center;
    margin-top: 0.5em;
  }
  select > option {
    background: white;
    color: black;
    text-align-last: center;
  }
  details.filters {
    margin: auto;
    padding: 0.1em;
  }
  details.filters > summary {
    list-style: none;
    text-align: center;
    /* padding: 0.3em 0.3em; */
    cursor: pointer;
    width: fit-content;
    margin: auto;
    /* max-width: fit-content; */
    /* color: white; */
    font-weight: 700;
    /* background-color: black; */
    /* border-radius: 0.5em; */
    background-color: whitesmoke;
    margin: 0.2em auto;
    padding: 0.2em;
    border-radius: 0.2em;
    border: 0.05em solid black;
  }
  details.filters summary::-webkit-details-marker {
    display:none;
  }
  details.filters:not([open]) > summary {
    font-size: 0.8em;
    /* max-width: fit-content; */
    /* color: white; */
    /* font-weight: 400; */
    /* background-color: black; */
    /* border-radius: 0.5em; */

    /* background-color: whitesmoke; */
    /* margin: 0.2em auto; */
    /* padding: 0.2em; */
    /* border-radius: 0.2em; */
    /* border: 0.05em solid black; */

    /* color: black; */
  }
  details.filters[open] > summary {
    font-size: 0.8em;
    /* background-color: white; */
    /* border-radius: 0.5em; */
    /* padding: 0.1e; */
  }
  form.fitler-form {
    background: white;
    position: relative;
  }
  fieldset.regions {
    height: fit-content;
  }
  fieldset > legend {
    font-size: 1em;
  }
  fieldset.regions > div {
    display: inline-block;
    width: 45%;
  }
  fieldset.sub-fieldset {
    border: 1px lightgray solid;
  }
  select {
    width: 100%;
  }
  fieldset {
    margin: auto;
    height: fit-content;
  }
  fieldset div {
    display: inline;
  }
  label.metric-checkbox {
    background-color: white;
    cursor: pointer;
    display: inline-block;
    width: 49%;
    height: 100%;
    border-radius: 0px;
    padding: 0.4em 0;
    border: 0px;
    text-align-last: center;
    margin: 0px;
    text-align: center;
  }
  label.metric-checkbox.selected {
    color: white;
    font-weight: bold;
    background-color: black;
  }
  label.metric-checkbox:hover {
    background-color: whitesmoke;
  }
  label.metric-checkbox.selected:hover {
    background-color: black;
  }
  label.per-capita-checkbox.selected {
    color: white;
    font-weight: 700;
    background-color: black;
  }
  label.per-capita-checkbox:hover {
    background-color: whitesmoke;
  }
  label.per-capita-checkbox.selected:hover {
    background-color: black;
  }
  fieldset label > input {
    display: none;
  }
  #plot {
    font-family: 'Times New Roman';
    font-size: 12px; /* Purposefully set and used to calculate the margin based on the device. Times New Roman is an extremely common font for devices, and using this handy calculator https://stackoverflow.com/a/118251/5935694 , Times New Roman's characters are about half the width of the pixels. So, 12px / 2 * the longest country name allows all country names to appear in full without being cut off. Ideally though, I'd be able to line break the country names or dynamically adjust the font size depending on the length of the country name, but idk how to do that yet and the common CSS things weren't garnering results. */
  }
  .table {
    margin: 1em;
    height: fit-content;
    overflow: auto;
  }
  table {
    table-layout: auto;
    border-collapse: collapse;
    border: 1px solid black;
  }
  table caption {
    text-align: left;
  }
  th, td, tr {
    border: 1px solid black;
    min-width: 50px;
  }
  div.open-an-issue {
    position: -webkit-sticky;
    position: sticky;
    bottom: 0px;
    right: 0px
  }
  .bar-separator {
    margin: 1em;
  }

  @media screen and (max-width: 720px) {
    h1 {
      font-size: 20px;
    }
    fieldset {
      padding: 0.2em;
    }
    .floating-plot-title {
      font-size: 1em;
    }
    h4 {
      font-size: 0.8em;
    }
  }
  div.loading {
    background-color: white;
    position: fixed;
    height: 100px;
    width: 100%;
    top: 30%;
    background: white;
    z-index: 500;
  }
  div.loading > .load-progress {
    background-color: white;
    margin: auto;
    margin-top: 1em;
    position: relative;
    display: block;
    width: 100%;
    height: fit-content;
    text-align: center;
    font-size: 1.5em;
  }
  .search-container {
    overflow-y: hidden;
    overflow-x: scroll;
    display: block;
  }
  .search-box-container {
    display: inline-block;
    width: 100%;
    overflow-x: visible;
    margin-bottom: 0.25em;
  }
  .location-search-box {
    margin: 0.2em;
    padding: 0.2em;
    text-shadow: 0 0 black;
  }
  .location-search-label {
    color: #525252;
    font-style: italic;
    font-size: 0.8em;
  }
  .location-tag {
    background-color: whitesmoke;
    margin: 0.2em;
    padding: 0.2em;
    border-radius: 0.2em;
    font-weight: 700;
    border: 0.05em solid black;
    width: fit-content;
    float: left;
    display: inline-block;
    cursor: pointer;
  }
  .add-location {
    margin: 0.1em;
    padding: 0.1em 0.3em;
    font-weight: 1000;
    background-color: white;
    border-radius: 0.2em;
  }
  .remove-location {
    margin: 0.1em;
    padding: 0.1em 0.3em;
    font-weight: 1000;
    background-color: black;
    color: white;
    border-radius: 0.2em;
  }
  .show-more-locations {
    padding: 0.1em 0.3em;
    background-color: whitesmoke;
    margin: 0.2em;
    padding: 0.2em;
    border-radius: 0.2em;
    font-weight: 700;
    border: 1px solid black;
    display: inline-block;
  }
  .tags {
    width: max-content;
    overflow-x: visible;
    display: inline-block;
  }
  .selected-tags {
    display: inline-block;
    width: 100%;
  }

  fieldset.location-search {
      min-inline-size: auto;
      overflow-x: hidden;
  }
  .no-results {
    margin: 0.2em;
    padding: 0.2em;
    width: fit-content;
    float: left;
    display: inline-block;
    color: grey;
    font-style: italic;
  }
  .floating-plot-title {
    width: 100%;
    text-align: center;
    font-weight: bold;
    font-size: 1.2em;
    /* height: fit-content; */
    /* background-color: white; */
  }
  /* START Not using this updating-chart & lds-ring at the moment. The positioning bits I learned still boggle my mind, so going to let those thoughts simmer and coalesce before refactoring it out. START */
  div.updating-chart {
    position: absolute;
    height: 100%;
    width: 100%;
    z-index: 1000;
    background: whitesmoke;
    opacity: 0.4;
  }
  div.updating-chart > div {
    width: 0;
    position: relative;
    padding: 15% 50% 15% 50%;
    margin: 0 0 0 -32px;
  }
  .lds-ring { /* https://loading.io/css/ "Open source CSS loading animations dedicated for speed, simplicity & dev-friendly." <== ! \O/ ! (big ups) */
    background: black;
  }
  .lds-ring div {
    box-sizing: border-box;
    display: block;
    position: absolute;
    width: 64px;
    height: 64px;
    margin: 8px;
    border: 8px solid #000;
    border-radius: 50%;
    animation: lds-ring 2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    border-color: #000 transparent transparent transparent;
  }
  .lds-ring div:nth-child(1) {
    animation-delay: -0.45s;
  }
  .lds-ring div:nth-child(2) {
    animation-delay: -0.3s;
  }
  .lds-ring div:nth-child(3) {
    animation-delay: -0.15s;
  }
  @keyframes lds-ring {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
  /* END Not using this updating-chart & lds-ring at the moment. The positioning bits I learned still boggle my mind, so going to let those thoughts simmer and coalesce before refactoring it out. END */

</style>

<body>
  <div class="sticky-nav">
    <nav class="main-menu hide">
      <div class="flex-vertically">
        <details>
          <summary>About</summary>
          <p>Learn more about this project <a href="https://github.com/trycrmr/covid-data-discovery/blob/master/README.md" target="_blank" rel="noreferrer noopener" alt="Learn more about this project by reading the README on the Github repo">by reading the README on the Github repo</a>.</p>
          <p>Follow <a href="https://twitter.com/coviddataweb" target="_blank" rel="noreferrer noopener" alt="Link to @coviddataweb's Twitter account">@coviddataweb</a> for the latest updates.</p>
        </details>
        <details>
          <summary>Data Dictionary</summary>
          <p>Cases include presumptive positive cases and probable cases, in accordance with CDC guidelines as of April 14.</p>
          <p>Death totals in the US include confirmed and probable, in accordance with CDC guidelines as of April 14.</p>
          <p>Survival Rate (%) = Number recorded deaths / Number confirmed cases.</p>
          <p>Data Granularity: County level - US; Province/State level - China, Canada, Australia; Country level - all other countries.</p>
          <p>All cases of COVID-19 in repatriated US citizens from the Diamond Princess are grouped together. These individuals have been assigned to various quarantine locations (in military bases and hospitals) around the US. This grouping is consistent with the CDC.</p>
          <p>The names of locations included on the Website correspond with the official designations used by the <a href="https://www.iso.org/home.html" target="_blank" rel="noreferrer noopener" alt="Link to International Organization for Standardization website">International Organization for Standardization</a>.</p>
        </details>
        <details>
          <summary>Data Sources</summary>
          <p><a href="https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series" target="_blank" rel="noreferrer noopener" alt="Link to JHU data source">Raw data</a> made available by Johns Hopkins Center for Systems Science and Engineering. Aggregated to 28 days worth of regional and global metrics by <a href="https://terrycreamer.codes" target="_blank" rel="noreferrer noopener" alt="Terry Creamer's personal website">Terry Creamer</a> (<a href="https://github.com/trycrmr/covid-data-batch-server/blob/5-jhu-load/createJHUGlobalTree.js" target="_blank" rel="noreferrer noopener" alt="Link to the code that uses the JHU raw data to create Global aggregates.">code</a>).</p> 
          <p>Note that the metrics on the <a href="https://www.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6" target="_blank" rel="noreferrer noopener" alt=" COVID-19 Dashboard by the Center for Systems Science and Engineering (CSSE) at Johns Hopkins University">COVID-19 Dashboard by the Center for Systems Science and Engineering (CSSE) at Johns Hopkins University</a> and the metrics denoted here will, likely, not match. They should be within a few days of each other and fairly close. Updated daily shortly after Center for Systems Science and Engineering (CSSE) at Johns Hopkins University's updates.</p>
        </details>
        <details>
          <summary>Suggest a Feature</summary>
          <p>Suggest a feature to coviddata.website by <a href="https://github.com/trycrmr/covid-data-discovery/issues" target="_blank" rel="noreferrer noopener" alt="Contact by opening an issue on Github.">opening an issue on Github</a>.</p>
          <p>Follow <a href="https://twitter.com/coviddataweb" target="_blank" rel="noreferrer noopener" alt="Link to @coviddataweb's Twitter account">@coviddataweb</a> for the latest feature updates.</p>
        </details>
        <details>
          <summary>Contact</summary>
          <p>Contact contributors to coviddata.website by <a href="https://github.com/trycrmr/covid-data-discovery/issues" target="_blank" rel="noreferrer noopener" alt="Contact by opening an issue on Github.">opening an issue on Github</a> or message <a href="https://twitter.com/coviddataweb" target="_blank" rel="noreferrer noopener" alt="Link to @coviddataweb's Twitter account">@coviddataweb</a> on Twitter.</p>
        </details>
        <ul class="hide">
          <li><a href="#table">Jump to Table</a></li>
          <li><a href="#top">Jump to Top</a></li>
        </ul>
      </div>
    </nav>
    <span class="toggle-menu">Show Menu</span>
  </div>
  <div class="loading">
    <span class="load-progress Data">Fetching Data: 0%</span>
    <span class="load-progress Charts">Fetching Charts: 0%</span>
  </div>
  <header id="top">
    <h1>COVID Data Website</h1>
    <h4>The latest data visualized in a mobile-friendly, fast, accessible, and <a href="https://github.com/trycrmr/covid-data-discovery/blob/master/CONTRIBUTING.md" target="_blank" rel="noreferrer noopener" alt="Link to how to contribute to coviddata.website">community-driven</a> manner. Follow <a href="https://twitter.com/coviddataweb" target="_blank" rel="noreferrer noopener" alt="Link to @coviddataweb's Twitter account">@coviddataweb</a> for the latest updates. <a href="https://github.com/trycrmr/covid-data-discovery/issues" target="_blank" rel="noreferrer noopener" alt="Report an issue on Github.">Report an "issue"</a> with any trouble or opinions.</h4>
    <h6><span class="last-updated">Last updated: [timestamp loading...]</span></h6>
    <h6> 
    </h6>
  </header>
  <hr />
  <div class="sticky-things">
    <div class="updating-chart" style="display: none;"><div>
      <div class="lds-ring"><div></div><div></div><div></div><div></div></div>
    </div></div>
    <div class="sticky-form" style="opacity: 0;">
      <details class="filters"> 
        <summary>Show Filters</summary>
        <form class="fitler-form">
          <fieldset class="location-search">
            <legend>Location Search</legend>
            <div class="search-container">
              <div class="search-box-container">
                <input class="location-search-box" name="location-search-box" id="location-search-box" type="text" placeholder="Type three letters..."/>
                <label for="location-search-box" class="location-search-label">Enter a location.</label>
              </div>
              <div class="tags"></div>
            </div>
          </fieldset>
          <fieldset>
            <legend>Metrics</legend>
            <div>
              <label class="metric-checkbox selected">Cases
                <input type="checkbox" value="cases" name="cases" checked>
              </label>
            </div>
            <div>
              <label class="metric-checkbox">Deaths
                <input type="checkbox" value="deaths" name="deaths">
              </label>
            </div>
            <fieldset class='sub-fieldset'>
              <legend>Derived Metrics</legend>
              <div>
                <label class="metric-checkbox">Daily Case Change (#)
                  <input type="checkbox" value="caseChange" name="cases">
                </label>
              </div>
              <!-- <div>
                <label class="metric-checkbox">Daily Case Change (%)
                  <input type="checkbox" value="caseChangePercent" name="deaths">
                </label>
              </div> -->
              <div>
                <label class="metric-checkbox">Daily Deaths Change (#)
                  <input type="checkbox" value="deathsChange" name="deaths">
                </label>
              </div>
              <!-- <div>
                <label class="metric-checkbox">Daily Deaths Change (%)
                  <input type="checkbox" value="deathsChangePercent" name="deaths">
                </label>
              </div> -->
              <!-- <div>
                <label class="metric-checkbox">Survival Rate (%)
                  <input type="checkbox" value="survivalRate" name="deaths">
                </label>
              </div> -->
            </fieldset>
            <fieldset class='sub-fieldset'>
              <legend>Toggle Per Capita ("Cases per 100,000 people")</legend>
              <div>
                <label class="per-capita-checkbox">Per Capita by 100,000
                  <input type="checkbox" value="perCapita" name="perCapita"> <!-- Just passes true or false, which can be captured with event.target.checked. Value is only set because label will also fire of an event, but it does not have a value for "checked" -->
                </label>
              </div>
            </fieldset>
          </fieldset>
        </form>
      </details>
      <div class="floating-plot-title"></div>
    </div>
  </div>
  <div id='plot'></div>
  <div class='table'></div>
  <!--[if IE]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
</body>
<script>
document.addEventListener("DOMContentLoaded", async(event) => {
  document.querySelector('span.toggle-menu').addEventListener('click', (e) => {
    document.querySelector('nav').classList.toggle('hide')
    document.querySelector('body').classList.toggle('disable-scroll')
    e.target.innerText = e.target.innerText === 'Show Menu' ? 'Hide Menu' : 'Show Menu'
  })
  document.querySelector('details.filters>summary').addEventListener('click', (e) => {
    e.target.innerText = e.target.innerText === 'Show Filters' ? 'Hide Filters' : 'Show Filters'
  })
  const app = new (await init()) // returns and instance of App

// [{ url, options, prettyName: 'Data' }, { url, options, prettyName: 'Charts' }...]
  const plotlyFetch = {
    url: '/plotly-1.53.0.min.js.gz', // Ideally would freeze plotly version. Limit dependencies moving underfoot and now we could be more generous with Cache-Control in the request. 
    options: {
      method: 'GET',
      headers: {
        'Content-Type': 'application/javascript',
        'Cache-Control': 'no-cache, max-age=43200',
        'Accept-Encoding': 'gzip;q=9.0'
      }
    },
    prettyName: 'Charts'
  }
  const dataFetch = {
    url: 'data.json.gz',
    options: {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache, max-age=43200',
        'Accept-Encoding': 'gzip;q=9.0'
      }
    },
    prettyName: 'Data'
  }

  const fetchResults = await app.fetchAll([plotlyFetch, dataFetch])
  document.querySelector('.loading').setAttribute('style', 'display: none;') // When all the assets have finished loading hide the loading container 
  app.updateState({ Plotly: fetchResults[0], data: fetchResults[1][0].data, meta: fetchResults[1][1].meta })
  app.updateTimestamp()
  app.createFullLocationList()
  document.querySelector('form').onkeypress = (e) => { // https://teamtreehouse.com/community/how-to-disable-submitting-a-form-when-i-press-on-the-enter-key
    let key = e.charCode || e.keyCode || 0;
    if (key == 13) {
      e.preventDefault()

      // This is a little convenience so the user does not need to take their hands off the keyboard. I mean, if they spam press enter, like, what are you doing? Stop.
      let currentLocationInput = document.querySelector('input[name=location-search-box]').value
      if(currentLocationInput.length > 3) { // First check length so the heavier check doesn't happen uselessly (no location names are shorter than three characters)
        currentLocationInput = `${currentLocationInput[0].toUpperCase()}${currentLocationInput.substring(1)}` // so asia becomes Asia but Asia is Asia, right? If you're screaming ASIA go away. Pretty brittle if country is two words. Also want to add mappings of common nicknames of countries are whatever. This will do for now. Gotta make sure it's a performant implementation, even on spam press. 
        if(app.state.allLocations.includes(currentLocationInput)) {
          app.setFilters('region', currentLocationInput)
          app.locationSearch(currentLocationInput)
        }
      }
    }
  }
  // app.updateForm()
  // app.updateState({ listeners: [...app.state.listeners, ...[ () => app.updatePlot('plot') ]] } ) // Left stubbed out in case because I expect to reincporate listeners in a smarter way at some point.
  app.locationSearch('') // Sets the initial filter as a location tag box to add & remove (has been "Earth", typically)
  app.updatePlot('plot')  
  document.querySelector('.sticky-form').removeAttribute('style') // Unhides the form. This is so folks don't play with the form before the data has loaded. Will entertain with updates on how the load is going.

  document.querySelector('input[name=location-search-box]').addEventListener('input', (event) => { app.locationSearch(event.target.value) })
  // document.querySelector('select[name=filter-regions]').addEventListener('change', (event) => app.setFilters('region', event.target.value))
  // document.querySelector('select[name=filter-subregions]').addEventListener('change', (event) => app.setFilters('region', event.target.value))
  document.querySelectorAll('.metric-checkbox').forEach(thisNode => thisNode.addEventListener('click', (event) => {
    if(!event.target.value) return undefined
    if(event.target.checked && !(app.state.filters.metric.includes(event.target.value))) {
      event.target.labels.forEach(thisLabel => thisLabel.classList.toggle('selected'))
      setTimeout(() => {
        app.setFilters('metric', [ ...app.state.filters.metric, event.target.value ])
      }, 10) // Give the browser a breath to update the UI
    } else if(!event.target.checked && app.state.filters.metric.length > 1) {
      event.target.labels.forEach(thisLabel => thisLabel.classList.toggle('selected'))
      setTimeout(() => {
        app.setFilters('metric', app.state.filters.metric.filter( metric => metric !== event.target.value ))
      }, 10) // Give the browser a breath to update the UI
    } else {
      return undefined
    }
  }))
  document.querySelector('.per-capita-checkbox').addEventListener('click', (event) => { 
    if(!event.target.value) return undefined
    event.target.labels[0].classList.toggle('selected')
    app.setFilters('perCapita', event.target.checked) 
  })
  // document.querySelector('input[name=toggle-subregions]').addEventListener('click', event => {
  //   if(!event.target.value) return undefined
  //   return app.setFilters('showSubregions', event.target.checked)
  // })
})
</script>
</html>
