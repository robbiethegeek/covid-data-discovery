<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title>COVID Data Website</title>
  <meta name="description" content="COVID-19 Data Discovery">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script type="text/javascript">
const init = (data) => {

const defaultState = { 
  data: data[0].data,
  meta: data[1].meta,
  formOptions: { region: ['Earth'], subregions: Object.keys(data[0].data.subregions).sort() },  
  filters: {region: ['Earth'], metric: ['cases'], showSubregions: false,
    prettyText: {
      "cases": "Cases",
      "deaths": "Deaths",
      "caseChange": "Daily Case Change (#)",
      "caseChangePercent": "Daily Case Change (%)",
      "deathsChange": "Daily Deaths Change (#)",
      "deathsChangePercent": "Daily Deaths Change (%)",
      "survivalRate": "Survival Rate (%)"
    }
  },
  debug: true,
  plot: { target: (id = 'plot') => { return document.getElementById(id) },
  config: undefined },
  listeners: []
}
return function App (state = defaultState) {
  this.log = output => console.debug(output)
  this.state = state
  this.updateTimestamp = (timeString = `${new Date(this.state.meta.lastUpdated).toLocaleString(undefined, {month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric', timeZoneName: 'short'})}`, className = '.last-updated') => { document.querySelector(className).innerText = `Last updated: ${timeString}` }
  this.updateState = (newState) => {
    if(!(JSON.stringify(this.state) === JSON.stringify({ ...this.state, ...newState }))) {
      if(this.state.debug) {
        this.log('=== Current State ===')
        this.log(this.state)
        this.log('=== State update ===')
        this.log(newState)
      }
      this.state = { ...this.state, ...newState }
      if(newState.filters) this.updatePlot('plot')
      if(this.state.debug) {
        this.log('=== New State ===')
        this.log(this.state)
        this.log(' ')
      }
      // this.state.listeners.forEach(thisListener => thisListener()); // Building the plot is a heavy operation with all the data to date, and a plot build will kick off unnecessarily like this. Stubbing this for now, but might incorporate this later in a smarter way. 
      return this.state
    } else {
      return this.state
    }
  }
  this.updateForm = (formSelection = 'Earth') => {
    let locationNode = this.findLocation(formSelection)
    let updatedState = this.updateState( { formOptions: {region: [ locationNode.name ], subregions: Object.keys(locationNode.subregions) } })

    ;((obj) => {
      let regionForm = document.getElementsByName('filter-regions')[0]
      regionForm.options.length = 0
      obj.region.forEach(thisRegion => { regionForm.options.add(new Option(thisRegion, thisRegion, false, false)) })
      while(locationNode.superRegionName) { // Will run until Earth, which has a null super region
        locationNode = this.findLocation(locationNode.superRegionName) // Could be a a perf issue eventually. No noticeable lag at the moment. 
        regionForm.options.add(new Option(locationNode.name, locationNode.name, false, false))
      }
      let subregionForm = document.getElementsByName('filter-subregions')[0]
      subregionForm.options.length = 0
      if(obj.subregions.length === 0) {
        subregionForm.options.add(new Option('No subregions available', 'Earth', false, false))
      } else {
        subregionForm.options.add(new Option('(Select a subregion)', 'Earth', false, false))
        obj.subregions.sort().forEach(thisSubregion => { subregionForm.options.add(new Option(thisSubregion, thisSubregion, false, false)) })
      }
    })(updatedState.formOptions)
    return undefined
  }
  this.findLocation = (str, obj = this.state.data) => {
    let match = null
    if(str === obj.name) {
      match = obj
      return match
    }
    if(Object.entries(obj.subregions).length > 0) {
      for (let [key, thisSubregion] of Object.entries(obj.subregions)) {
        match = this.findLocation(str, thisSubregion)
        if(!match) {
          // do nothing
        } else {
          return match
        }
      }
    }
    return match
  }
  this.setFilters = (type, filters) => {
    switch(type) {
      case 'region':
        this.updateForm(filters)
        return this.updateState( { filters: { ...this.state.filters, region: [ filters ] } } )
      case 'metric':
        return this.updateState( { filters: { ...this.state.filters, metric: [ ...filters ] } } )
      case 'showSubregions':
        return this.updateState( { filters: { ...this.state.filters, showSubregions: filters } } )
      default:
        return this.state
    }
  }
  this.updatePlot = (id, type) => { 
    let thisPlotConfig = this.getPlotConfig(type, this.state.filters)
    let newState = this.updateState( { plot: { ...this.state.plot, ... { config: { data: thisPlotConfig[0], layout: thisPlotConfig[1]} } } } ) 
    this.state.plot.target(id)
    Plotly.newPlot(this.state.plot.target(id), newState.plot.config.data, newState.plot.config.layout, { responsive: true }).catch(err => console.error(err)) // Handle this error some other way later
    document.querySelector('div.table').remove()
    document.getElementById(id).append(this.generateTable(newState.plot.config.data, { title: newState.plot.config.layout.title.text }))
    document.getElementsByTagName('body')[0].setAttribute('style', `height: ${Math.max( document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight )}px;`)
  }
  this.getPlotConfig = (type = 'time series', filters = this.state.filters, plotLayout = undefined) => {
    let calculatedHeight
    let calculatedMarginWidth
    let currentFontSize = parseFloat(getComputedStyle(this.state.plot.target()).fontSize)
    plotLayout = { title: this.state.filters.metric
      .map(thisMetric => this.state.filters.prettyText[thisMetric])
      .sort((a, b) => a.localeCompare(b))
      .reduce((acc, curr, currIdx, origArr) => { // Really didn't get creative here code-wise because I didn't want to mess up and edge cases with the titles. Conditionals for the win!
        if(currIdx === 0) acc = `${curr}`
        if(origArr.length === 1 && this.state.filters.region[0] !== 'Earth') return acc + ` in ${this.state.filters.region[0]}`
        if(origArr.length === 1 && this.state.filters.region[0] === 'Earth') return acc + ` on ${this.state.filters.region[0]}`
        if(origArr.length === 2 && currIdx === 0) return acc
        if(origArr.length === 2 && currIdx === 1 && this.state.filters.region[0] !== 'Earth') return acc + ` and ${curr} in ${this.state.filters.region[0]}`
        if(origArr.length === 2 && currIdx === 1 && this.state.filters.region[0] === 'Earth') return acc + ` and ${curr} on ${this.state.filters.region[0]}`
        if(origArr.length >= 2 && currIdx === origArr.length - 1) acc = acc + `, and ${curr}`
        if(currIdx === origArr.length - 1 && this.state.filters.region[0] !== 'Earth') return acc + ` in ${this.state.filters.region[0]}`
        if(currIdx === origArr.length - 1 && this.state.filters.region[0] === 'Earth') return acc + ` on ${this.state.filters.region[0]}`
        if(origArr.length >= 2 && currIdx !== origArr.length - 1 && currIdx > 0) acc = acc + `, ${curr}`
        return acc
      }, '')
    },
    plotLayout = { 
      ...plotLayout,
      font: {
        family: getComputedStyle(document.getElementById('plot')).fontFamily,
        size: getComputedStyle(document.getElementById('plot')).fontSize,
        color: getComputedStyle(document.getElementById('plot')).color
      },
      autosize: false,
      width: parseFloat(getComputedStyle(this.state.plot.target()).width),
      height: window.innerHeight - (document.querySelector('header').offsetHeight) - 72 > 600 ? window.innerHeight - (document.querySelector('header').offsetHeight) - 72 : 600,
      // height needs to be set dynamically based on the screen size and height of other items on the screen. Ideally, when the filters are hidden, the bottom of the chart should be just above the fold. 
      yaxis: { 
        tickfont: { size: currentFontSize }, 
      }
    }
    if(this.state.filters.metric.length > 1) plotLayout = { ...plotLayout, barmode: 'group'  }
    let plotData = undefined
    switch(type) { // Written as a switch keeping the future feature open to allow the user to select different types of charts. Tough to ensure the UI looks decent between each of the charts with all the cuts of the metrics over time, but it's possible. 
      case 'time series':
        const timeFormat = {month: 'short', day: 'numeric', timeZone: 'UTC' } // use with toLocaleDateString to create x-axis dates
        let locationNode = this.findLocation(this.state.filters.region[0])
        let locationNodes = this.state.filters.showSubregions && Object.keys(locationNode.subregions).length > 0 ? [...Object.keys(locationNode.subregions).map(thisSubregion => locationNode.subregions[thisSubregion]), locationNode ] : [ locationNode ]
        //^ If the user wants the subregions visualized and the location has subregions, get the subregions. Otherwise, just return the location.
        plotData = this.state.filters.metric.map(thisMetric => {
          let locationsWithoutData = []
          return locationNodes.reduce((acc, curr, currIdx, origArr) => {
            try {
              let obj = { x: [], y: [], text: [], type: 'scatter', mode: 'lines+markers', name: `${curr.name} (${this.state.filters.prettyText[thisMetric]})`, hoverlabel: { namelength :-1 } /* Hoverlabel -1 ensures the labels that show on hover are not cut off and replaced with an ellipsis */ }
              if(this.state.filters.region[0] === curr.name && locationNodes.length > 1) obj = { ...obj, line: { width: 1, dash: 'dot' }, marker: { size: 8 } }
              obj.x = [ ...Object.keys(curr.totals.daily[thisMetric]).map(thisUnixEpochString => parseInt(thisUnixEpochString)) ]
              obj.y = [ ...Object.values(curr.totals.daily[thisMetric]) ]
              if(parseInt(obj.x[0]) > parseInt(obj.x[1])) { // band aid fix to preserve order. Date to metric key-value pairs are stored as a hashmap and that's making it real tough to ensure the order. https://github.com/trycrmr/covid-data-batch-server/issues/6
                obj.x = obj.x.reverse()
                obj.y = obj.y.reverse()
              }

              if((thisMetric === 'caseChangePercent' || thisMetric === 'deathsChangePercent')) { // When deriving these metrics the first day of a time series, I guess, technically, would be 100% change from the previous day, which is effectively zero. This skews the plots, especially when the percent change should approach zero. Handling this on the back-end when the derived calculations are generated wouldn't work because null values are type cast to zero when generating the aggregates. That necessitates this hard check and setting the first value if it's a percent aggregate and the percent aggregate is 100 (i.e. 100%)
                let i = 0
                while(i < obj.y.length) { // A little nervous about the while loop with performance, but so far no noticeable loss on local development. 
                  if( (!+(obj.y[i]) || obj.y[i] === "0.00" ) || obj.y[i] === "100.00") { // Woof. If the value when type cast to a number is falsy OR the it's equal to "0.00" (a legitimate value) set it to null. ALSO if the value is "100.00" it's the first day of counts were recorded, but that messes up the visualization, so set that one to null too. Oof. 
                    obj.y[i] = null
                    i++
                    if(i === obj.y.length) locationsWithoutData.sort().push(curr.name)
                  } else {
                    break
                  }
                }
              } 
              obj.x = obj.x.map(thisUnixEpoch => new Date(thisUnixEpoch).toLocaleDateString(undefined, timeFormat)) 
              if(locationsWithoutData.length > 0 && locationNodes.length === 1) alert(`${curr.name} does not have any ${this.state.filters.prettyText[thisMetric]} data. This is okay! 

It means this is either the first day cases or deaths were recorded for ${curr.name} and a percentage-based derived metric is selected or there haven't been any cases or deaths of COVID-19 reported so far! 

If you do not believe that's the situation, please report an issue (use the link at the top of the page) with the filters (i.e metrics & locations) you have selected.
              `)
              //^ This is for all the lovely people in Ouray, Colorado :-) . Sorry about reporting your first case on April 6th, and your first death around April 10th :-( . Use the state of Wyoming, select all the metrics, and show subregions to test instead. 
              return [ ...acc, obj ]
            } catch(err) {
              console.error(err)
              return acc
            }
          }, [])
        }).flat()

        plotLayout = { ...plotLayout, 
          ...{
            // hovermode: 'closest', // Hover will only show the closest point to the cursor, instead of all the points on that part of the x-axis. Leaving option for reference and to toggle for UX experiments on occasion. 
            showLegend: true,
            legend: { "orientation": 'h', x: 0, y: 0 },
            xaxis: { // puts the x-axis on the top of the page so the user can see the scale when the page loads and as they adjust the filters
              ...plotLayout.xaxis,
              mirror: 'allticks',
              side: plotData.length > 1 ? 'top' : 'bottom',
              fixedrange: true, // disables zoom; It can be disorienting and makes scrolling more difficult on mobile
              showspikes: true, // on hover, a dotted line will track to either axis and display the labels,
              tickformat: ','
            },
            yaxis: { ...plotLayout.yaxis,
              fixedrange: true,
              showspikes: true,
            }
          }  
        }
        break
      default:
        plotData = [
          {
            x: ['oops', 'something', 'went', 'wrong'],
            y: [20, 14, 23, 12],
            type: 'bar'
          }
        ]
    }
    return [plotData, plotLayout]
  }
  this.generateTable = (data, details) => {
    let header = data.reduce((acc, curr, currIdx, origArr) => {
      let thisRow = `<th>${curr.name}</th>`
      if(currIdx === origArr.length - 1) thisRow += '</tr></thead>'
      return acc += thisRow
    }, '<thead><tr><th></th>')

    let dataPointCount = data[0].x.length
    let metricCount = data.length
    let rows = '<tbody>'
    for (let i = 0; i < dataPointCount; i++) {
      rows += `<tr><th>${data[0].x[i]}</th>`
      for (let j = 0; j < metricCount; j++) {
        rows += `<td>${data[j].y[i]}</td>`
        if(metricCount - 1 === j) rows += `</tr>`
      }
    }

    let html = `<div class="table" id="table"><table><caption>${details.title}</caption>${header}${rows}`
    html += `</tbody></table></div>`
    return document.createRange().createContextualFragment(html)
  }
}

}
  </script>
  <!-- <link rel="manifest" href="site.webmanifest"> -->
  <!-- <link rel="apple-touch-icon" href="icon.png"> -->
  <!-- Place favicon.ico in the root directory -->
  <!-- ^ Some stuff from HTML5 boilerplate for later I don't want to forget about. -->
</head>

<style>
  hr {
    width: 40%;
    max-width: 400px;
    margin: 0.2em auto;
  }
  header {
    margin: auto;
    max-width: 1000px;
    text-align: center;
  }
  h1, h2, h3, h4, h5, h6 {
    margin: 0.5em;
  }
  .sticky-nav {
    position: -webkit-sticky;
    position: sticky;
    top: 0px;
    right: 1em;
    background-color: white;
    height: fit-content;
    z-index: 999;
  }
  .sticky-form {
    position: -webkit-sticky; 
    position: sticky;
    top: 1em;
    margin: auto;
    height: fit-content;
    max-width: 780px;
    width: 100%;
    z-index: 999;
  }
  nav {
    position: -webkit-sticky;
    position: fixed;
    bottom: 1em;
    right: 1em;
    background-color: transparent;
    margin: auto;
    height: fit-content;
    z-index: 999;
    font-size: 12px;
    line-height: 2em;
  }
  nav > ul {
    list-style-type: none;
    padding: 0px;
    margin: auto;
    list-style-type: none;
  }
  body {
    font-family: 'Times New Roman';
    font-size: 1em;
    position: relative;
  }
  select {
    font-family: 'Times New Roman';
    font-size: 1em;
    background-color: black;
    color: white;
    font-weight: bold;
    border-radius: 0.5em;
    text-align-last: center;
    margin-top: 0.5em;
  }
  select > option {
    background: white;
    color: black;
    text-align-last: center;
  }
  details {
    margin: auto;
    padding: 0.1em;
  }
  details > summary {
    list-style: none;
    text-align: center;
    font-size: 1em;
    padding: 0.3em 0.3em;
    cursor: pointer;
  }
  details summary::-webkit-details-marker {
    display:none;
  }
  details:not([open]) {
    max-width: fit-content;
    color: white;
    font-weight: bold;
    background-color: black;
    border-radius: 0.5em;
  }
  details[open] > summary {
    background-color: white;
    border-radius: 0.5em;
  }
  form.fitler-form {
    background: white;
  }
  fieldset.regions {
    height: fit-content;
  }
  fieldset > legend {
    font-size: 1em;
  }
  fieldset.regions > div {
    display: inline-block;
    width: 45%;
  }
  fieldset.sub-fieldset {
    border: 1px lightgray solid;
  }
  select {
    width: 100%;
  }
  fieldset.metrics {
    margin: auto;
    text-align-last: justify;
    height: fit-content;
  }
  fieldset.metrics div {
    /* display: inline-block; */
    display: inline;
  }
  label.metric-checkbox {
    line-height: 2em;
    /* padding: 0.5em; */
    background-color: white;
    /* border: 1px solid black; */
    /* border-radius: 0.5em; */
    cursor: pointer;

    display: inline-block;
    width: 49%;
    height: 100%;
    border-radius: 0px;
    padding: 0px;
    border: 0px;
    text-align-last: center;
    margin: 0px;
  }
  label.metric-checkbox.selected {
    color: white;
    font-weight: bold;
    background-color: black;
  }
  fieldset.metrics label > input {
    display: none;
  }
  #plot {
    /* height: 100vh; */
    font-family: 'Times New Roman';
    font-size: 12px; /* Purposefully set and used to calculate the margin based on the device. Times New Roman is an extremely common font for devices, and using this handy calculator https://stackoverflow.com/a/118251/5935694 , Times New Roman's characters are about half the width of the pixels. So, 12px / 2 * the longest country name allows all country names to appear in full without being cut off. Ideally though, I'd be able to line break the country names or dynamically adjust the font size depending on the length of the country name, but idk how to do that yet and the common CSS things weren't garnering results. */
  }
  .table {
    margin: 1em;
    height: fit-content;
    overflow: auto;
  }
  table {
    table-layout: auto;
    border-collapse: collapse;
    border: 1px solid black;
  }
  table caption {
    text-align: left;
  }
  th, td, tr {
    border: 1px solid black;
    min-width: 50px;
  }
  div.open-an-issue {
    position: -webkit-sticky;
    position: sticky;
    bottom: 0px;
    right: 0px
  }
  .bar-separator {
    margin: 1em;
  }

  @media screen and (max-width: 720px) {
    h1 {
      font-size: 20px;
    }
    fieldset {
      font-size: 0.8em !important /* lazy, probably breaks something */
    }
}
</style>

<body>
  <div class="sticky-nav">
    <nav class="header">
      <ul>
        <li><a href="#table">Jump to Table</a></li>
        <li><a href="#top">Jump to Top</a></li>
      </ul>
    </nav>
  </div>
  <header id="top">
    <h1>COVID Data Website</h1>
    <h4>The latest data visualized in a mobile-friendly, fast, accessible, and <a href="https://github.com/trycrmr/covid-data-discovery/blob/master/CONTRIBUTING.md" target="_blank" rel="noreferrer noopener" alt="Link to how to contribute to coviddata.website">community-driven</a> manner. <a href="https://github.com/trycrmr/covid-data-discovery/issues" target="_blank" rel="noreferrer noopener" alt="Report an issue on Github.">Report an "issue"</a> with any trouble or opinions.</h4>
    <h6><a href="https://github.com/trycrmr/covid-data-discovery/blob/master/README.md" target="_blank" rel="noreferrer noopener" alt="Learn more about this project by reading the README on the Github repo">About</a><span class="bar-separator">|</span><a href="https://github.com/trycrmr/covid-data-discovery/issues" target="_blank" rel="noreferrer noopener" alt="Contact by opening an issue on Github.">Contact (Open an issue)</a><span class="bar-separator">|</span><span class="last-updated">Last updated: [timestamp loading...]</span></h6>
    <h6><a href="https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series" target="_blank" rel="noreferrer noopener" alt="Link to JHU data source">Raw data</a> made available by Johns Hopkins Center for Systems Science and Engineering. Aggregated to 28 days worth of regional and global metrics by <a href="https://terrycreamer.codes" target="_blank" rel="noreferrer noopener" alt="Terry Creamer's personal website">Terry Creamer</a> (<a href="https://github.com/trycrmr/covid-data-batch-server/blob/5-jhu-load/createJHUGlobalTree.js" target="_blank" rel="noreferrer noopener" alt="Link to the code that uses the JHU raw data to create Global aggregates.">code</a>). Note that the metrics on <a href="https://www.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6" target="_blank" rel="noreferrer noopener" alt="Johns Hopkins Center for Systems Science and Engineering dashboard of their COVID-19 metrics">JHUCSSE's Dashboard</a> and the metrics denoted here will, likely, not match. They should be within a few days of each other and fairly close. Updated daily shortly after JHUCSSE's updates. 
    </h6>
  </header>
  <hr />
  <div class="sticky-form" id="top">
    <details open="true"> 
      <summary>Filters (Click to show/hide)</summary>
      <form class="fitler-form">
        <fieldset class="regions">
          <legend>Choose a region or subregion</legend>
          <div style="float: left;">
            <fieldset class='sub-fieldset'>
              <legend>Region</legend>
              <select name="filter-regions">
              </select>
            </fieldset>
          </div>
          <div style="float: right;">
            <fieldset class='sub-fieldset'>
              <legend>Subregion
                <label for="toggle-subregions">(show <input type="checkbox" name="toggle-subregions" style="vertical-align: middle; margin: 0px;">) </label>
              </legend>
              <select name="filter-subregions">
              </select>
            </fieldset>
          </div>
        </fieldset>
        <fieldset class="metrics">
          <legend>Choose a few metrics and derived metrics</legend>
          <div style="float: left;">
            <fieldset class='sub-fieldset'>
              <legend>Metrics</legend>
              <div>
                <label class="metric-checkbox selected">Cases
                  <input type="checkbox" value="cases" name="cases" checked>
                </label>
              </div>
              <div>
                <label class="metric-checkbox">Deaths
                  <input type="checkbox" value="deaths" name="deaths">
                </label>
              </div>
              <div style="float: right;">
                <fieldset class='sub-fieldset'>
                  <legend>Derived Metrics</legend>
                  <div>
                    <label class="metric-checkbox">Daily Case Change (#)
                      <input type="checkbox" value="caseChange" name="cases">
                    </label>
                  </div>
                  <div>
                    <label class="metric-checkbox">Daily Case Change (%)
                      <input type="checkbox" value="caseChangePercent" name="deaths">
                    </label>
                  </div>
                  <div>
                    <label class="metric-checkbox">Daily Deaths Change (#)
                      <input type="checkbox" value="deathsChange" name="deaths">
                    </label>
                  </div>
                  <div>
                    <label class="metric-checkbox">Daily Deaths Change (%)
                      <input type="checkbox" value="deathsChangePercent" name="deaths">
                    </label>
                  </div>
                  <div>
                    <label class="metric-checkbox">Survival Rate (%)
                      <input type="checkbox" value="survivalRate" name="deaths">
                    </label>
                  </div>
                </fieldset>
              </div>
            </fieldset>
          </div>
        </fieldset>
      </form>
    </details>
  </div>
  <div id='plot'></div>
  <div class='table'></div>
  <!--[if IE]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
</body>
<script>
document.addEventListener("DOMContentLoaded", async(event) => {
  const getData = async(url, config) => {
    try {
      const data = await fetch(url, config)
      const jsonData = await data.json()
      return jsonData
    } catch (err) {
      console.error(err)
    }
  }

  const thisData = await getData('data.json.gz', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'no-cache, max-age=0',
      'Accept-Encoding': 'gzip;q=9.0'
    },
  })
  const app = new (init(thisData)) // returns and instance of App
  app.updateForm()
  app.updateTimestamp()
  // app.updateState({ listeners: [...app.state.listeners, ...[ () => app.updatePlot('plot') ]] } ) // Left stubbed out in case because I expect to reincporate listeners in a smarter way at some point.
  app.updatePlot('plot')
  
  document.querySelector('select[name=filter-regions]').addEventListener('change', (event) => app.setFilters('region', event.target.value))
  document.querySelector('select[name=filter-subregions]').addEventListener('change', (event) => app.setFilters('region', event.target.value))
  document.querySelectorAll('.metric-checkbox').forEach(thisNode => thisNode.addEventListener('click', (event) => {
    if(!event.target.value) return undefined
    if(event.target.checked && !(app.state.filters.metric.includes(event.target.value))) {
      event.target.labels.forEach(thisLabel => thisLabel.classList.toggle('selected'))
      app.setFilters('metric', [ ...app.state.filters.metric, event.target.value ])
    } else if(!event.target.checked && app.state.filters.metric.length > 1) {
      event.target.labels.forEach(thisLabel => thisLabel.classList.toggle('selected'))
      app.setFilters('metric', app.state.filters.metric.filter( metric => metric !== event.target.value ))
    } else {
      return undefined
    }
  }))
  document.querySelector('input[name=toggle-subregions]').addEventListener('click', event => {
    if(!event.target.value) return undefined
    return app.setFilters('showSubregions', event.target.checked)
  })
})
</script>
</html>
